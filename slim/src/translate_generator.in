/*
 * translate_generator.in - 
 *
 *   Copyright (c) 2008, Ueda Laboratory LMNtal Group <lmntal@ueda.info.waseda.ac.jp>
 *   All rights reserved.
 *
 *   Redistribution and use in source and binary forms, with or without
 *   modification, are permitted provided that the following conditions are
 *   met:
 *
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *
 *    3. Neither the name of the Ueda Laboratory LMNtal Group nor the
 *       names of its contributors may be used to endorse or promote
 *       products derived from this software without specific prior
 *       written permission.
 *
 *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Id: translate_generator.in,v 1.5 2008/09/19 05:18:17 riki Exp $
 */

#__echo_t
 #include "translate.h"
 #include "syntax.h"
 #include "arch.h"
 #include "symbol.h"
 #include "error.h"
 #include <stdio.h>

/* just for debug! */
static FILE *OUT = NULL;

const BYTE *translate_instruction_generated(const BYTE *instr,
                                            Vector *jump_points,
                                            const char *header,
                                            const char *successcode,
                                            const char *failcode,
                                            int indent,
                                            int *finishflag)
{
  LmnInstrOp op;
  READ_VAL(LmnInstrOp, instr, op);
  *finishflag = 1;

  /* just for debug! */
  if(! OUT){
    //OUT = stderr;
    //OUT = stdout;
    OUT = fopen("/dev/null", "w");
  }

  switch (op) {


#spec LmnInstrVar LmnInstrVar
  TR_INSTR_SPEC($1);

#commit lmn_interned_str LmnLineNum
  //commit($0, $1);

#loadruleset LmnInstrVar LmnRulesetId
  lmn_mem_add_ruleset((LmnMembrane*)wt[$0], lmn_ruleset_from_id(TR_GRID($1)));

#newatom LmnInstrVar LmnInstrVar $functor
% switch(targ2_attr){
% case LMN_INT_ATTR:
    wt[$0] = $2_long_data;
%   break;
% case LMN_DBL_ATTR:
    wt[$0] = malloc(sizeof(double));
    *(double*)wt[$0] = $2_double_data;
%   break;
% case LMN_STRING_ATTR:
    wt[$0] = $2_string_data;
%   break;
% default:
    wt[$0] = LMN_ATOM(lmn_new_atom(TR_GFID($2_functor_data)));
%   break;
% }
    at[$0] = $2_attr;
  lmn_mem_push_atom((LmnMembrane*)wt[$1], wt[$0], $2_attr);

#alloclink LmnInstrVar LmnInstrVar LmnInstrVar
  TR_INSTR_ALLOCLINK($0, $1, $2);

#unifylinks LmnInstrVar LmnInstrVar LmnInstrVar
  TR_INSTR_UNIFYLINKS($0, $1, $2);

#enqueueatom LmnInstrVar

#proceed
  $s;
% *finishflag = 0;

#findatom LmnInstrVar LmnInstrVar $functor
% if(LMN_ATTR_IS_DATA(targ2_attr)){
%   fprintf(stderr, "I can not find data atoms.\n");
%   assert(FALSE);
% }else{
    {
      AtomListEntry *atomlist_ent = lmn_mem_get_atomlist((LmnMembrane*)wt[$1], TR_GFID($2_functor_data));
      LmnSAtom atom;
  
      if (atomlist_ent) {
        at[$0] = LMN_ATTR_MAKE_LINK(0);
        /* EACH_ATOMを使うとループ内コード中でコンマが使えない場合が出てくる */
        for(atom = atomlist_head(atomlist_ent);
            atom != lmn_atomlist_end(atomlist_ent);
            atom = LMN_SATOM_GET_NEXT_RAW(atom)){
          if(LMN_SATOM_GET_FUNCTOR(atom) != LMN_RESUME_FUNCTOR){
            wt[$0] = (LmnWord)atom;
#__echo_t
            instr = translate_instructions(instr, jump_points, header, successcode, "continue", indent+1);
#__format
          }
        }
      }
    }
    $f;
% }
% *finishflag = 0;

#derefatom LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)LMN_SATOM(LMN_SATOM_GET_LINK(wt[$1], $2));
  at[$0] = LMN_SATOM_GET_ATTR(wt[$1], $2);

#isint LmnInstrVar
  if(at[$0] != LMN_INT_ATTR) $f;

#iadd LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] + (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#isub LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] - (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#imul LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] * (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#idiv LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] / (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#ineg LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)(-(long)wt[$1]);
  at[$0] = LMN_INT_ATTR;

#imod LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] % (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#inot LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)(~(long)wt[$1]);
  at[$0] = LMN_INT_ATTR;

#iand LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] & (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#ior LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] | (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#ixor LmnInstrVar LmnInstrVar LmnInstrVar
  wt[$0] = (LmnWord)((long)wt[$1] ^ (long)wt[$2]);
  at[$0] = LMN_INT_ATTR;

#ilt LmnInstrVar LmnInstrVar
  if(!((long)wt[$0] < (long)wt[$1])) $f;

#ile LmnInstrVar LmnInstrVar
  if(!((long)wt[$0] <= (long)wt[$1])) $f;

#igt LmnInstrVar LmnInstrVar
  if(!((long)wt[$0] > (long)wt[$1])) $f;

#ige LmnInstrVar LmnInstrVar
  if(!((long)wt[$0] >= (long)wt[$1])) $f;

#ieq LmnInstrVar LmnInstrVar
  if(!((long)wt[$0] == (long)wt[$1])) $f;

#ine LmnInstrVar LmnInstrVar
  if(!((long)wt[$0] != (long)wt[$1])) $f;

#allocatom LmnInstrVar $functor
  at[$0] = $1_attr;
% switch(targ1_attr){
% case LMN_INT_ATTR:
    wt[$0] = $1_long_data;
%   break;    
% case LMN_DBL_ATTR:
    {
      static const double d = $1_double_data;
      wt[$0] = &d;
    }
%   break;
% case LMN_STRING_ATTR:
    wt[$0] = $1_string_data;
    at[$0] = LMN_CONST_STR_ATTR;
%   break;
% default:
%   lmn_fatal("Implementation error");
% }

#dequeueatom LmnInstrVar

#removeatom LmnInstrVar LmnInstrVar
  lmn_mem_remove_atom((LmnMembrane*)wt[$1], wt[$0], at[$0]);

#copyatom LmnInstrVar LmnInstrVar LmnInstrVar
  at[$0] = at[$2];
  wt[$0] = lmn_copy_atom(wt[$2], at[$2]);
  lmn_mem_push_atom((LmnMembrane *)wt[$1], wt[$0], at[$0]);

#relink LmnInstrVar LmnInstrVar LmnInstrVar LmnInstrVar LmnInstrVar
  TR_INSTR_RELINK($0, $1, $2, $3, $4);

#freeatom LmnInstrVar
  lmn_free_atom(wt[$0], at[$0]);

#getfunc LmnInstrVar LmnInstrVar
  if(LMN_ATTR_IS_DATA(at[$1])){
    wt[$0] = wt[$1];
  }else{
    wt[$0] = (LmnWord)LMN_SATOM_GET_FUNCTOR(wt[$1]);
  }
  at[$0] = at[$1];

#allocatomindirect LmnInstrVar LmnFunctor
  if (LMN_ATTR_IS_DATA(at[$1])) {
    wt[$0] = lmn_copy_data_atom(wt[$1], at[$1]);
    at[$0] = at[$1];
  } else { /* symbol atom */
    fprintf(stderr, "symbol atom can't be created in GUARD\n");
    exit(EXIT_FAILURE);
  }

#newlink LmnInstrVar LmnInstrVar LmnInstrVar LmnInstrVar LmnInstrVar
  lmn_mem_newlink((LmnMembrane *)wt[$4], wt[$0], at[$0], $1, wt[$2], at[$2], $3);

#newmem LmnInstrVar LmnInstrVar LmnInstrVar
  {
    LmnMembrane *mp = lmn_mem_make();
    lmn_mem_add_child_mem((LmnMembrane*)wt[$1], mp);
    wt[$0] = (LmnWord)mp;
    lmn_mem_set_active(mp, TRUE);
    if (RC_GET_MODE(rc, REACT_MEM_ORIENTED)) {
      lmn_memstack_push(RC_MEMSTACK(rc), mp);
    }
  }

#deref LmnInstrVar LmnInstrVar LmnInstrVar LmnInstrVar
  {
    LmnByte attr = LMN_SATOM_GET_ATTR(wt[$1], $2);
    if (LMN_ATTR_IS_DATA(attr)) {
      if ($3 != 0) $f;
    } else {
      if (attr != $3) $f;
    }
    wt[$0] = LMN_SATOM_GET_LINK(wt[$1], $2);
    at[$0] = attr;
  }

#func LmnInstrVar $functor
% if(LMN_ATTR_IS_DATA(targ1_attr)){
    if(LMN_ATTR_IS_DATA(at[$0]) && at[$0]==$1_attr){
%     switch(targ1_attr){
%     case LMN_INT_ATTR:
        if(wt[$0] != $1_long_data) $f;
%       break;
%     case LMN_DBL_ATTR:
        //if(*(double*)wt[$0] != $1_double_data) $f;
%       fprintf(stderr, "double attr is not implemented.");
%       break;
%     case LMN_STRING_ATTR:
%       fprintf(stderr, "string attr is not implemented.");
%       break;
%     default:
%       lmn_fatal("implementation error");
%     }
    }else{
      $f;
    }
% }else{
    if(LMN_ATTR_IS_DATA(at[$0]) ||
       LMN_SATOM_GET_FUNCTOR(LMN_SATOM(wt[$0])) != TR_GFID($1_functor_data)) $f;
% }
 
#unify LmnInstrVar LmnInstrVar LmnInstrVar LmnInstrVar LmnInstrVar
  lmn_mem_unify_atom_args((LmnMembrane *)wt[$4], LMN_SATOM(wt[$0]), $1, LMN_SATOM(wt[$2]), $3);

#loadmodule LmnInstrVar lmn_interned_str
  {
    LmnRuleSet ruleset;
    if ((ruleset = lmn_get_module_ruleset(TR_GSID($1)))) {
%     /* テーブル内にルールセットがある場合 */
      lmn_mem_add_ruleset((LmnMembrane*)wt[$0], ruleset);
    } else {
%     /* テーブル内にルールセットがない場合 */
      fprintf(stderr, "Undefined module %s\n", lmn_id_to_name(TR_GSID($1)));
    }
  }

#getlink LmnInstrVar LmnInstrVar LmnInstrVar
% /* リンク先の取得をせずにリンク元の情報を格納しておく。
%    リンク元が格納されていることを示すため最下位のビットを立てる */
  wt[$0] = LMN_SATOM_GET_LINK(wt[$1], $2);
  at[$0] = LMN_SATOM_GET_ATTR(wt[$1], $2);

#eqatom LmnInstrVar LmnInstrVar
  if (LMN_ATTR_IS_DATA(at[$0]) ||
      LMN_ATTR_IS_DATA(at[$1]) ||
      LMN_SATOM(wt[$0]) != LMN_SATOM(wt[$1])) $f;

#neqatom LmnInstrVar LmnInstrVar
  if (!(LMN_ATTR_IS_DATA(at[$0]) ||
        LMN_ATTR_IS_DATA(at[$1]) ||
        LMN_SATOM(wt[$0]) != LMN_SATOM(wt[$1]))) $f;

#anymem LmnInstrVar LmnInstrVar LmnInstrVar lmn_interned_str
  {
    LmnMembrane *mp = ((LmnMembrane*)wt[$1])->child_head;
    for (; mp; mp=mp->next) {
      wt[$0] = (LmnWord)mp;
      if (RC_GET_MODE(rc, REACT_ND)) { at[$0] = 0; /* MC */ }
      if (mp->name == TR_GSID($2)){
#__echo_t
        instr = translate_instructions(instr, jump_points, header, successcode, "continue", indent+1);
#__format
      }
    }
    $f;
  }
% *finishflag = 0;

#norules LmnInstrVar
  if(((LmnMembrane *)wt[$0])->rulesets.num) $f;

#removemem LmnInstrVar LmnInstrVar
  lmn_mem_remove_mem((LmnMembrane *)wt[$1], (LmnMembrane *)wt[$0]);

#removeproxies LmnInstrVar
  lmn_mem_remove_proxies((LmnMembrane *)wt[$0]);

#insertproxies LmnInstrVar LmnInstrVar
  lmn_mem_insert_proxies((LmnMembrane *)wt[$0], (LmnMembrane *)wt[$1]);

#movecells LmnInstrVar LmnInstrVar
  lmn_mem_move_cells((LmnMembrane *)wt[$0], (LmnMembrane *)wt[$1]);

#freemem LmnInstrVar
  lmn_mem_free((LmnMembrane*)wt[$0]);

#samefunc LmnInstrVar LmnInstrVar
  if (!lmn_eq_func(wt[$0], at[$0], wt[$1], at[$1])) $f;

#lockmem LmnInstrVar LmnInstrVar lmn_interned_str
  wt[$0] = (LmnWord)LMN_PROXY_GET_MEM(wt[$1]);
  if (RC_GET_MODE(rc, REACT_ND)) { at[$0] = 0; /* MC */ }

#isunary LmnInstrVar
  if (LMN_ATTR_IS_DATA(at[$0])) {
    switch (at[$0]) {
    case LMN_SP_ATOM_ATTR:
      /* スペシャルアトムはgroundの結果をunaryの結果とする */
      if (!SP_ATOM_IS_GROUND(wt[$0])) $f;
      break;
    default:
      break;
    }
  } else if (LMN_SATOM_GET_ARITY(wt[$0]) != 1){
    $f;
  }

#nfreelinks LmnInstrVar LmnInstrVar
  if (!lmn_mem_nfreelinks((LmnMembrane *)wt[$0], $1)) $f;

#natoms LmnInstrVar LmnInstrVar
  if(!lmn_mem_natoms((LmnMembrane*)wt[$0], $1)) $f;

#nmems LmnInstrVar LmnInstrVar
  if(!lmn_mem_nmems((LmnMembrane*)wt[$0], $1)) $f;

#neqmem LmnInstrVar LmnInstrVar
  if(wt[$0] == wt[$1]) $f;

#removetoplevelproxies LmnInstrVar
  lmn_mem_remove_toplevel_proxies((LmnMembrane *)wt[$0]);

#removetemporaryproxies LmnInstrVar
  lmn_mem_remove_temporary_proxies((LmnMembrane *)wt[$0]);

#copyrules LmnInstrVar LmnInstrVar
  TR_INSTR_COPYRULES($0, $1);

#recursivelock LmnInstrVar

#neqfunc LmnInstrVar LmnLinkAttr
  if (at[$0] == at[$1]) {
    switch (at[$0]) {
    case LMN_INT_ATTR:
      if ((long)wt[$0] == (long)wt[$1]) $f;
      break;
    case LMN_DBL_ATTR:
      if (*(double*)(&wt[$0]) ==
          *(double*)(&wt[$1])) $f;
      break;
    default:
      if (wt[$0] == wt[$1]) $f;
      break;
    }
  }


#__end


#__echo_t
  default:
    /* always failure */
    *finishflag = -1;
    return instr;
  }
}

