% AUTHOR: Takayuki Ayano

% wSize(6)  -> swp_ws6.il
% wSize(7)  -> swp_ws7.il
% wSize(8)  -> swp_ws8.il
% wSize(9)  -> swp_ws9.il
% wSize(10) -> swp_ws10.il

% property0: メッセージを送信したら, 必ずいつか応答を得られる
% property1: Strong Fairness -> property0

{
 wSize(4).     // ウィンドウサイズ
 nMAX(5).      // 再送処理などの制御に利用するナンバーnの上限値
 idMAX(3).     // 送信データの正当さをチェックするidの上限値
 error(false). // エラー検出フラグ
 
 sender{ n(0), nextId(0), sucId(0), c(0). }. // データ送信者
 ss=rr.                                      // データが通る通信路
 rs=sr.                                      // ACKが通る通信路
 receiver{ n(0), expId(0). }.                // データ受信者
 
 // 送信者 : データの送信 sender -> [data]
 sd@@ sender{ n(N), nextId(ID), sucId(SucID), c(C) }, nMAX(NMAX), idMAX(IDMAX), wSize(W), ss=SC
   :- C<W, C_=C+1, DN=(N+C) mod NMAX, ID_=(ID+1) mod IDMAX, int(SucID)
   |  sender{ n(N), nextId(ID_),sucId(SucID), c(C_)}, nMAX(NMAX), idMAX(IDMAX), wSize(W), ss=[data(DN,ID)|SC].
 
 // 受信者 : データ受信，ACKの返送(予期していたデータ) [data] -> receiver -> [ack]
 rs@@ receiver{ n(N), expId(EID) }, nMAX(NMAX), idMAX(IDMAX), SC=[data(DN,ID)|rr], rs=RC
   :- N=:=DN, EID=:=ID, N_=(N+1) mod NMAX, EID_=(EID+1) mod IDMAX
    | receiver{ n(N_),expId(EID_)}, nMAX(NMAX), idMAX(IDMAX), SC=rr, rs=[ack(DN)|RC].
 
 // 受信者 : データ受信，ACKの返送(受信するはずのデータの消失検出) [data] -> receiver -> [ack]
 ru@@ receiver{ n(N), expId(EID) }, SC=[data(DN,ID)|rr], rs=RC
   :- N=\=DN, int(ID), int(EID), ground(SC)
    | receiver{ n(N), expId(EID) }, ss=rr, rs=[ack(DN)|RC].
 
 // 受信者 : データ受信(正しいメッセージでない) [data] -> receiver -> error
 re@@ error(false), receiver{ n(N), expId(EID) }, SC=[data(DN,ID)|rr], rs=RC, sender{ $p[] }
   :- N=:=DN, EID=\=ID, ground(SC), ground(RC)
    | error(true).
 
 // 送信者 : ACKの受信(予期していたACK) [ack] -> slide
 s@@ sender{ n(N), nextId(NextID), sucId(SucID), c(C) }, nMAX(NMAX), idMAX(IDMAX), RC=[ack(ACK)|sr]
  :- N=:=ACK, C>0, N_=(N+1) mod NMAX, SucID_=(SucID+1) mod IDMAX, C_=C-1, int(NextID)
   | sender{ n(N_),nextId(NextID), sucId(SucID_),c(C_)}, nMAX(NMAX), idMAX(IDMAX), RC=sr.
 
 // 送信者 : ACKの受信(データかACKの消失検出) [ack] -> reset
 r@@ sender{ n(N), nextId(NextID),sucId(SucID), c(C) }, SC=rr, RC=[ack(ACK)|sr]
  :- N=\=ACK, int(NextID), int(SucID), int(C), int(ACK), ground(SC), ground(RC)
   | sender{ n(N), nextId(SucID), sucId(SucID), c(0) }, ss=rr, rs=sr.
 
 // 送信者 : タイムアウトの検出 [timeout] -> reset
 t@@ sender{ n(N), nextId(NextID),sucId(SucID), c(C) }, timeout
  :- int(N), int(NextID), int(SucID), int(C)
   | sender{ n(N), nextId(SucID), sucId(SucID), c(0) }.
 
 // 通信路 : データ,ACKの消失 [data] -> [], [ack] -> []
 ld@@ X=[data(DN,ID)|Y] :- int(DN),int(ID) | X=Y.
 la@@ X=[ack(ACK)|Y] :- int(ACK) | X=Y .
}.
// タイムアウトの発生 [] -> [timeout]
o@@ { error(false), $p, @p }/ :- { timeout, error(false), $p, @p }.