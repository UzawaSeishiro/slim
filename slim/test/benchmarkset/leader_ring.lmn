% leader_ring.lmn
%       2009.08.10 gocho
%
%  Leader Election Algorithm
%    Logical Ring Algorithm
% 
% http://www.f.waseda.jp/nakazato/1506-08Elect.pdf
% http://fan.naist.jp/~kounoe/lecture/compII/compII_03/compII7_10.pdf

% Phase: Initialization
%   Processes form a logical ring.
%   Each process knows which process comes after it.

% p_num=4  -> leader_ring_p4.il
% p_num=5  -> leader_ring_p5.il
% p_num=6  -> leader_ring_p6.il
% p_num=7  -> leader_ring_p7.il
% p_num=8  -> leader_ring_p8.il

% property0: いつか必ずリーダーは存在する
%            ※全員crashした状態が反例(leaderどころかプロセスがいない)

{
  init{
    p_num=3. // # of processes
    init1 @@
      p_num(P) :- Q=P-1 |
      p_set(Q,P), list=[p{id(P), leader(-1)}].
    init2 @@
      p_set(Q,Z), list=[X |F] :- P=Q-1, Q>0 |
      p_set(P,Z), list=[p{id(Q), leader(-1)}, X |F].
    init3 @@
      p_set(0,Z), list=E, F=[] :-
      p_fin(Z), E=F.
  }.
  
  phase(normal).
%  INIT (c.f, p_num=3): ring list                
%    ---------------------------------------    
%    |                                     |    phase(special) <-> phase(normal)
%    ----o--------------o--------------o----    
%   _____|_____    _____|_____    _____|_____    
%  |     +     |  |     +     |  |     +     |   
%  | id(1)     |  | id(2)     |  | id(3)     |
%  | leader(?) |  | leader(?) |  | leader(?) |
%  |___________|  |___________|  |___________|
%  

  init_finalize @@ % start 1st election
    init{$i,@i, p_fin(P), p{$p}}/,     phase(normal) :- int(P), Q=P+1 |
    $i, p_num(P), p{$p, msg(elect,Q)}, phase(special).


  % Try connection using ring
  send__Sync @@
    phase(special), E=[L0         |F], p{+L0, id(I), sync(Mt,Min), $p} :- int(I), ground(Mt), int(Min) |
    phase(special), E=[L0, sys(I) |F], p{+L0, id(I), wait(Mt,Min), $p}.
  pass__Sync @@
    phase(special), E=[    sys(S), L0 |F], p{+L0, crash, $p} :-
    phase(special), E=[L0, sys(S)     |F], p{+L0, crash, $p}.
  agree_Sync @@
    phase(special), E=[sys(S), L0 |F], p{+L0, id(I), $p} :- int(I),int(S),\+($p=($q, crash)) |
    phase(special), E=[        L0 |F], p{+L0, id(I), $p}, ack(I,S).
  recv__Ack_ @@
    phase(special), p{id(I), wait(Mt,Mi), $p}, ack(F,T) :- I=:=T,ground(Mt),int(Mi),int(F) |
    phase(special), p{id(I), $p}, msg(Mt,Mi,F).
  recv__Msg_ @@
    phase(special), p{id(I), $p}, msg(Mt,Mi,T) :- ground(Mt),int(Mi),I=:=T |
    phase(special), p{id(I), msg(Mt,Mi), $p}.

  try__Elect @@
    phase(special), p{id(ID), msg(elect, Min), $p} :- ID<Min |
    phase(special), p{id(ID), sync(elect,ID),  $p}.
  lose_Elect @@
    phase(special), p{id(ID), msg(elect, Min), $p} :- ID>Min |
    phase(special), p{id(ID), sync(elect,Min), $p}.
  win__Elect @@
    phase(special), p{id(ID),  msg(elect,    Min), leader(L),  $p} :- ID=:=Min, int(L) |
    phase(special), p{id(ID), sync(coord(ID),Min), leader(ID), $p}.
    
  sendLeader @@
    phase(special), p{id(ID),  msg(coord(C),Min), leader(L), $p} :- int(Min),C=\=ID,int(L) |
    phase(special), p{id(ID), sync(coord(C),Min), leader(C), $p}. 
  end__Coord @@
    phase(special), p{id(ID), msg(coord(C),Min), $p} :- ID=:=C, int(Min) |
    phase(special), p{id(ID),                    $p}.
  }.

% Leader Election is finished.
electEND @@
  {$p, @p, phase(special)}/ :-
  {$p, @p, phase(normal)}.

% when phase=normal, Leader process might be crashed
crash__L @@
  {$p[L],@p, phase(normal), p{+L, id(I), leader(W)}}/ :- I=:=W |
  {$p[L],@p, phase(normal), p{+L, id(I), leader(W), crash}}.

% when phase=normal, 
% If Others noticed that Leader has crashed, then they start the new election.
notice_L @@
  {$p[L,R], @p, phase(normal), p{+L, id(I), leader(Z)},
  p{+R, id(J), leader(W), crash}, p_num(P)}  :- Q=P+1,J=:=W,Z=:=J,int(I) |
  {$p[L,R], @p, phase(normal), p{+L, id(I), leader(-1), msg(elect,Q)},
  p{+R, id(J), leader(W), crash}, p_num(P)}.

start_SP @@
  {$p, @p, phase(normal),  p{$q, msg(A,B)}} :- unary(A), int(B) |
  {$p, @p, phase(special), p{$q, msg(A,B)}}.