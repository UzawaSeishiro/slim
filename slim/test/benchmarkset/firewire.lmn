% firewire.lmn
%    2009.08.20  gocho
%
% Leader Election for Tree Identifier Protocol of IEEE1394
%  
%   The Leader Election Protocol of IEEE 1394 in Maude
%   Using SPIN to Analyse the Tree Identification Phase of the IEEE 1394
%        High-Performance Serial Bus (FireWire) Protocol

% property0: leaderが2人以上になることはない(sefety: leaderは常に1人以下)
% property1: 必ずいつかleaderが決まる(liveness: leaderが決まらないサイクルを探す)
%            ※contentionが無限に続くサイクルが反例として見つかる
% property2: Strong Fairness -> property2
%            Contentionが無限に続かないことをFairnessで保証してあげる
%            Fairness1. nodeがphase(contention)からphase(ack)に遷移できること
%            Fairness2. nodeがphase(waitParent)からphase(self)に遷移できること

% NetWork6  -> firewire_nw6.il
% NetWork7  -> firewire_nw7.il
% NetWork8  -> firewire_nw8.il
% NetWork9  -> firewire_nw9.il
% NetWork10 -> firewire_nw10.il

% Init Process

% NetWork6
node{id(a), neig{num(1), +AC},         children{}, phase(rec)}.
node{id(b), neig{num(1), +BC},         children{}, phase(rec)}.
node{id(c), neig{num(3), +AC,+BC,+CE}, children{}, phase(rec)}.
node{id(e), neig{num(3), +CE,+EF,+EG}, children{}, phase(rec)}.
node{id(f), neig{num(1), +EF},         children{}, phase(rec)}.
node{id(g), neig{num(1), +EG},         children{}, phase(rec)}.

/*
% NetWork7
node{id(a), neig{num(1), +AC},         children{}, phase(rec)}.
node{id(b), neig{num(2), +BC,+BD},     children{}, phase(rec)}.
node{id(c), neig{num(3), +AC,+BC,+CE}, children{}, phase(rec)}.
node{id(d), neig{num(1), +BD},         children{}, phase(rec)}.
node{id(e), neig{num(3), +CE,+EF,+EG}, children{}, phase(rec)}.
node{id(f), neig{num(1), +EF},         children{}, phase(rec)}.
node{id(g), neig{num(1), +EG},         children{}, phase(rec)}.
*/
/*
% NetWork8
node{id(a), neig{num(1), +AC},         children{}, phase(rec)}.
node{id(b), neig{num(2), +BC,+BD},     children{}, phase(rec)}.
node{id(c), neig{num(3), +AC,+BC,+CE}, children{}, phase(rec)}.
node{id(d), neig{num(2), +BD,+BI},     children{}, phase(rec)}.
node{id(e), neig{num(3), +CE,+EF,+EG}, children{}, phase(rec)}.
node{id(f), neig{num(2), +EF,+FI},     children{}, phase(rec)}.
node{id(g), neig{num(1), +EG},         children{}, phase(rec)}.
node{id(i), neig{num(2), +BI,+FI},     children{}, phase(rec)}.
*/
/*
% NetWork9
node{id(a), neig{num(1), +AC},         children{}, phase(rec)}.
node{id(b), neig{num(2), +BC,+BD},     children{}, phase(rec)}.
node{id(c), neig{num(3), +AC,+BC,+CE}, children{}, phase(rec)}.
node{id(d), neig{num(2), +BD,+BI},     children{}, phase(rec)}.
node{id(e), neig{num(3), +CE,+EF,+EG}, children{}, phase(rec)}.
node{id(f), neig{num(2), +EF,+FI},     children{}, phase(rec)}.
node{id(g), neig{num(1), +EG},         children{}, phase(rec)}.
node{id(i), neig{num(3), +BI,+FI,+IH}, children{}, phase(rec)}.
node{id(h), neig{num(2), +HK,+IH},     children{}, phase(rec)}.
node{id(j), neig{num(1), +JK},         children{}, phase(rec)}.
node{id(k), neig{num(3), +HK,+JK,+KL}, children{}, phase(rec)}.
node{id(l), neig{num(3), +KL,+LM,+LN}, children{}, phase(rec)}.
node{id(m), neig{num(1), +LM},         children{}, phase(rec)}.
node{id(n), neig{num(1), +LN},         children{}, phase(rec)}.
*/
/*
% NetWork10
node{id(a), neig{num(1), +AC},         children{}, phase(rec)}.
node{id(b), neig{num(2), +BC,+BD},     children{}, phase(rec)}.
node{id(c), neig{num(3), +AC,+BC,+CE}, children{}, phase(rec)}.
node{id(d), neig{num(2), +BD,+BI},     children{}, phase(rec)}.
node{id(e), neig{num(3), +CE,+EF,+EG}, children{}, phase(rec)}.
node{id(f), neig{num(2), +EF,+FI},     children{}, phase(rec)}.
node{id(g), neig{num(1), +EG},         children{}, phase(rec)}.
node{id(i), neig{num(3), +BI,+FI,+IH}, children{}, phase(rec)}.
node{id(h), neig{num(2), +HK,+IH},     children{}, phase(rec)}.
node{id(j), neig{num(1), +JK},         children{}, phase(rec)}.
node{id(k), neig{num(3), +HK,+JK,+KL}, children{}, phase(rec)}.
node{id(l), neig{num(5), +KL,+LM,+LN,+LO,+LP}, children{}, phase(rec)}.
node{id(m), neig{num(1), +LM},         children{}, phase(rec)}.
node{id(n), neig{num(1), +LN},         children{}, phase(rec)}.
node{id(o), neig{num(1), +LO},         children{}, phase(rec)}.
node{id(p), neig{num(1), +LP},         children{}, phase(rec)}.
*/
% Rewriting Rule
%%%%  TODO: Delay is not implemented

% Phase: Rec (親要求を受信する)
recv_MSG1 @@ % 親要求を受信した隣接ノードFを子ノードとする(ただし隣接ノード数2以上の場合)
  msg(from(F), to(T), be_my_parent), 
  node{phase(rec), neig{num(Nu), +T, $n}, children{    $c}, $p}  :- Nu>1, N2=Nu-1 |
  node{phase(rec), neig{num(N2),     $n}, children{+F, $c}, $p}.
recv_MSG2 @@ % 親要求を受信した隣接ノードFを子ノードとする. 隣接ノード数1の場合, そのままphase:ackへ移行する
  msg(from(F), to(T), be_my_parent),
  node{phase(rec), neig{num(1), +T}, children{    $c}, $p} :- 
  node{phase(ack), neig{num(0)    }, children{+F, $c}, $p}.
recv_end_ @@ % 未通信の隣接ノード数が残1ならば, phase:ackへ移行する
  node{phase(rec), neig{num(1), $n}, $p} :-
  node{phase(ack), neig{num(1), $n}, $p}.

% Especially!
pass_MSG_ @@ % 双方向に送信があると, 受信できずに固まってしまうため, exchangeする
  msg(from(A), to(T), Msg1), msg(from(B), to(T), Msg2) :-
  msg(from(F), to(B), Msg1), msg(from(F), to(A), Msg2).

% Phase: Ack (親要求を送信してきた子ノードへ, 認証としてAckを返す)
acknowled @@ % 子ノードへAckを返す. Ack送信済みのリンクのシンボルアトムを'+'から'-'へ書き換えることで区別する.
  node{phase(ack), children{+J, $c}, $p} :-
  node{phase(ack), children{-Z, $c}, $p},
  msg(from(Z), to(J), acknowledgement).
ackParent @@ % 未通信隣接ノードがある場合or leaf: 全ての子ノードへのAckが終了したら, 未通信隣接ノードへ親要求をする
  node{phase(ack),        neig{num(1), +N}, children{$c}, $p} :- \+($c=($q,'+'(L))) |
  node{phase(waitParent), neig{num(1), +Z}, children{$c}, $p},
  msg(from(Z), to(N), be_my_parent).
ackLeader @@ % 未通信隣接ノードがない場合: 全ての子ノードへのAckが終了したならば, 自分がリーダーであることを主張する.
  node{phase(ack),  id(I), neig{num(0)}, children{$c}, $p}    :- \+($c=($q,'+'(L))), unary(I) |
  node{phase(self), id(I), neig{num(0)}, children{$c}, $p}, leader(I).

% Phase: WaitParent
wait_p_1_ @@ % ackParent後の処理A: 親要求したノードからAckが来たならば, 終了(phase:selfへ移行)
  msg(from(F), to(T), acknowledgement), 
  node{phase(waitParent), neig{num(1), +T}, children{$c}, $p} :- \+($c=($q,'+'(L))) |
  node{phase(self),       neig{num(1), +F}, children{$c}, $p}.
wait_p_2_ @@ % ackParent後の処理B: 親要求したノードから親要求が来たならば, phase:contentionへ移行
  msg(from(F), to(T), be_my_parent),
  node{phase(waitParent), neig{num(1), +T}, children{$c}, $p} :- \+($c=($q,'+'(L))) |
  node{phase(contention), neig{num(1), +F}, children{$c}, $p}.

% Phase: Contention
cont_Recv @@ % election lose!: 自分が再送する前に, 再送された親要求を受信したら, Ackを返す(phase:ackへ)
  msg(from(F), to(T), be_my_parent), 
  node{phase(contention), neig{num(1), +T}, children{    $c}, $p} :- \+($c=($q,'+'(L))) |
  node{phase(ack),        neig{num(0)    }, children{+F, $c}, $p}.
cont_Send @@ % election retry: 親要求を再送し, 再びAckを待つ()
  node{phase(contention), neig{num(1), +N}, $p} :- 
  node{phase(waitParent), neig{num(1), +Z}, $p},
  msg(from(Z), to(N), be_my_parent).
   